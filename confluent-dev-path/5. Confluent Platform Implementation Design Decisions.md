# Implementation Design Decisions

## Konfigurasi Daya Tahan dan Ketersediaan Message

![image](https://github.com/user-attachments/assets/71e6c259-bf7d-4b3f-b25c-1afb276dd50d)

- message disebut "committed" saat diterima oleh semua replika dalam daftar ISR
- Consumer hanya dapat membaca message yang telah dikomit
- Leader memutuskan kapan akan mengkomit message
  - Status komit ditandai pada titik pemeriksaan ke disk
 
![image](https://github.com/user-attachments/assets/2fdbfd2a-f24d-4e87-99ef-56e17eea60b2)

- Setiap partisi dapat direplikasi. Setiap replika berada pada broker yang berbeda. Ada satu leader dan replika lainnya adalah follower.
- Replika In-Sync (ISR) adalah daftar replika - baik leader maupun follower - yang identik hingga titik tertentu yang disebut titik tertinggi.
- Jika follower terlalu lambat, leader akan menghapusnya dari ISR ​​dan menyimpan ISR di ZooKeeper.
- Controller mendengarkan ZooKeeper untuk perubahan pada metadata Partisi (lebih lanjut tentang ini nanti).
- Jika leader gagal, daftar ISR yang digunakan oleh Pengendali untuk memilih leader baru.

## Pertahanan Urutan dan Keunikan message

![image](https://github.com/user-attachments/assets/985df86b-3e74-4fce-92b4-9524850b9414)

Properti produser max.in.flight.requests.per.connection, yang default-nya 5, mengontrol jumlah ProduceRequests yang tidak diakui yang dapat dikirim dari satu produser ke broker secara bersamaan. Meskipun ini meningkatkan throughput, hal ini dapat menyebabkan pengiriman message yang tidak teratur. 

Misalnya, jika produser mengirim batch m2 dan m3, dan m2 gagal sementara m3 berhasil, m3 dapat tercatat sebelum m2, mengakibatkan ketidakkonsistenan. Namun, mengaktifkan idempotence (default diatur ke true) mengurangi masalah ini dengan menetapkan ID produser unik dan nomor urut untuk setiap message, memastikan bahwa pengiriman yang tidak teratur ditangani dengan benar. Jika batch message gagal, batch berikutnya juga ditandai sebagai gagal hingga pemulihan terjadi, yang dapat difasilitasi oleh file snapshot yang menyimpan pemetaan ID produser ke nomor urut.

![image](https://github.com/user-attachments/assets/ad84f103-aaea-42ec-a60b-5fad50b15cad)

Produser idempotent mencegah catatan duplikat selama sesi produser yang sama, terutama ketika acks=all diatur dan beberapa catatan direplikasi oleh satu pengikut. Jika pemilihan pemimpin terjadi, broker memeriksa nomor urut message yang masuk. Jika duplikat ditemukan, broker mengabaikan catatan dan mengembalikan respons DUP kepada klien. Tanpa idempotence, message tersebut akan diduplikasi.

## Manage Consumer Group Offsets

Properti konsumer auto.offset.reset menentukan apa yang harus dilakukan jika tidak ada posisi yang dikomit (yang akan terjadi saat grup pertama kali diinisialisasi) atau saat offset berada di luar rentang, yaitu kurang dari offset awal log saat ini atau lebih besar dari offset akhir log.

| Value   | Deskripsi                               |
|---------|-----------------------------------------|
| earliest| Mengatur offset ke yang paling awal tersedia |
| latest  | Mengatur offset ke yang paling baru tersedia |
| none    | Membuang pengecualian jika tidak ada offset valid ditemukan |

Reset offset juga bisa dilakukan secara manual, contohnya dengan command berikut yang mereset offset ke datetime tertentu:

```
kafka-consumer-groups \
    --bootstrap-server kafka-1:9092 \
    --group my-group \
    --topic my_topic \
    --reset-offsets \
    --execute \
    --to-datetime 2021-06-01T17:14:23.933
```

Dalam java, untuk reset ke timestamp tertentu, bisa gunakan code berikut:

```
for (TopicPartition partition : partitions) { 
    timestampsToSearch.put(partition, MY_TIMESTAMP);
}

Map<TopicPartition, OffsetAndTimestamp> result = consumer.offsetsForTimes(timestampsToSearch); 

for (Map.Entry<TopicPartition, OffsetAndTimestamp> entry : result.entrySet()) {
    consumer.seek(entry.getKey(), entry.getValue().offset()); 
}
```

Dalam kode di atas, proses adalah sebagai berikut:
1. Tambahkan setiap Partisi dan stempel waktu ke HashMap
2. Dapatkan offset untuk setiap Partisi
3. Cari offset yang ditentukan untuk setiap Partisi

Pada contoh ini, consumer akan `seekToBeginning` dari semua partisi topik my_topic:

```
ConsumerRebalanceListener listener = new  
    ConsumerRebalanceListener() {
        @Override
        public void onPartitionsRevoked(Collection<TopicPartition> partitions) {
            // nothing to do...
        }

        @Override
        public void onPartitionsAssigned(Collection<TopicPartition> partitions) {
            consumer.seekToBeginning(partitions);
        }
    };
consumer.subscribe(Arrays.asList("my_topic"), listener);  
consumer.poll(Duration.ofMillis(0));  
```

Dalam kode di atas, proses adalah sebagai berikut:
1. Daftarkan ConsumerRebalanceListener
2. Berlangganan topik my_topic
3. Polling untuk catatan dari partisi yang ditetapkan

## Manage Ukuran message yang Besar

Kafka tidak dioptimalkan untuk message besar, dengan ukuran batch maksimum default 1 MB. Batch record yang lebih besar dapat menyebabkan masalah kinerja, seperti fragmentasi Java heap.
Meningkatkan batas ukuran message dapat mengakibatkan:
- Kinerja pengumpulan sampah JVM broker yang buruk
- Memori yang lebih sedikit tersedia untuk tugas broker lainnya
- Lebih banyak sumber daya yang diperlukan untuk menangani permintaan
- Permintaan ambil konsumer dan replika yang tidak efisien

Jika harus mengubah batas ukuran untuk message Kafka, modifikasi pengaturan konfigurasi berikut:

| Component | Setting                  |
|-----------|--------------------------|
| producer  | max.request.size         |
| broker    | message.max.bytes (cluster default) |
| topic     | max.message.bytes        |

![image](https://github.com/user-attachments/assets/93f1b98e-e379-4d1c-8b13-5456b7465330)

Mengaktifkan kompresi pada produsen akan mengurangi ukuran kumpulan record yang menghasilkan penurunan bandwidth jaringan dan persyaratan penyimpanan.
- KafkaProducer mengompresi message dan menambahkannya ke kumpulan record
- Kumpulan record terkompresi dikirim ke broker
- Broker menyimpan kumpulan record terkompresi
- record terkompresi dikirim ke konsumer
- KafkaConsumer mendekompresi record

Untuk mengaktifkan kompresi, ubah properti compression.type produsen dari none menjadi gzip, snappy, lz4, atau zstd.

- Kompresi berlaku untuk kumpulan data penuh, jadi kemanjuran pengelompokan juga akan memengaruhi rasio kompresi (semakin banyak pengelompokan berarti kompresi yang lebih baik).

- Jenis kompresi yang digunakan oleh produsen dicatat di header kumpulan record.

- Consumer mendekompresi kumpulan message sesuai dengan jenis kompresi yang ditunjukkan di header.

Jika kompresi saja tidak cukup, maka strategi lain adalah menyimpan pesan besar dalam penyimpanan objek seperti S3, database dokumen seperti MongoDB, atau cache seperti Redis, lalu menghasilkan referensi ke lokasi sebenarnya data tersebut ke Kafka. Jika itu juga tidak cukup, maka pertimbangkan untuk memecah muatan besar menjadi "potongan-potongan" dan mengirim potongan-potongan tersebut sebagai pesan individual.

![image](https://github.com/user-attachments/assets/897f5134-a64a-40a1-a702-3ccf7d0b2a27)

## Multi-Region Cluster

Confluent Server dapat di-deploy di berbagai zona ketersediaan atau pusat data, tetapi perbedaan dalam keandalan jaringan, latensi, bandwidth, atau biaya dapat menyebabkan masalah kinerja, seperti peningkatan latensi dan throughput yang lebih rendah. Untuk mengatasi tantangan ini, tiga fungsi utama diperkenalkan:

- Follower-Fetching
- Observers
- Penempatan Replica

### Follower Fetching

![image](https://github.com/user-attachments/assets/9f5f8895-9e10-4e4b-8d06-a9d922b39e8b)

Client diizinkan untuk mengonsumsi dari follower. Hal ini secara drastis mengurangi jumlah lalu lintas lintas pusat data antara client dan broker jika hanya boleh melewati leader.

Untuk mengaktifkannya, konfigurasi di server.properties, tempat broker.rack mengidentifikasi lokasi broker. Tidak harus berupa rak, tetapi dapat berupa wilayah tempat broker berada:

```
replica.selector.class=org.apache.kafka.common.replica.RackAwareReplicaSelector
broker.rack=<rack-ID>
```

Pada klien konsumer, tetapkan properti `client.rack`.

```
client.rack=<rack-ID>
```

### Observers

![image](https://github.com/user-attachments/assets/c4d7bbd6-8482-4630-be4e-81b97550f401)

Selain leader dan follower, Multi-Region Clusters memperkenalkan observer sebagai jenis replikasi ketiga. Observer tidak bergabung dengan in-sync replicas (ISR) dan mereplikasi data secara asinkron, yang menghindari masalah throughput terkait acks=all di jaringan dengan latensi tinggi. Dengan menggunakan observer, replikasi data dapat dilakukan secara sinkron dalam satu wilayah dan secara asinkron antar wilayah, sehingga meningkatkan kinerja keseluruhan karena leader tidak menunggu status observer.
