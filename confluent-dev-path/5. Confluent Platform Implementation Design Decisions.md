# Implementation Design Decisions

## Konfigurasi Daya Tahan dan Ketersediaan Message

![image](https://github.com/user-attachments/assets/71e6c259-bf7d-4b3f-b25c-1afb276dd50d)

- Pesan disebut "committed" saat diterima oleh semua replika dalam daftar ISR
- Consumer hanya dapat membaca pesan yang telah dikomit
- Leader memutuskan kapan akan mengkomit pesan
  - Status komit ditandai pada titik pemeriksaan ke disk
 
![image](https://github.com/user-attachments/assets/2fdbfd2a-f24d-4e87-99ef-56e17eea60b2)

- Setiap partisi dapat direplikasi. Setiap replika berada pada broker yang berbeda. Ada satu leader dan replika lainnya adalah follower.
- Replika In-Sync (ISR) adalah daftar replika - baik leader maupun follower - yang identik hingga titik tertentu yang disebut titik tertinggi.
- Jika follower terlalu lambat, leader akan menghapusnya dari ISR ​​dan menyimpan ISR di ZooKeeper.
- Controller mendengarkan ZooKeeper untuk perubahan pada metadata Partisi (lebih lanjut tentang ini nanti).
- Jika leader gagal, daftar ISR yang digunakan oleh Pengendali untuk memilih leader baru.

## Pertahanan Urutan dan Keunikan Pesan

![image](https://github.com/user-attachments/assets/985df86b-3e74-4fce-92b4-9524850b9414)

Properti produser max.in.flight.requests.per.connection, yang default-nya 5, mengontrol jumlah ProduceRequests yang tidak diakui yang dapat dikirim dari satu produser ke broker secara bersamaan. Meskipun ini meningkatkan throughput, hal ini dapat menyebabkan pengiriman pesan yang tidak teratur. 

Misalnya, jika produser mengirim batch m2 dan m3, dan m2 gagal sementara m3 berhasil, m3 dapat tercatat sebelum m2, mengakibatkan ketidakkonsistenan. Namun, mengaktifkan idempotence (default diatur ke true) mengurangi masalah ini dengan menetapkan ID produser unik dan nomor urut untuk setiap pesan, memastikan bahwa pengiriman yang tidak teratur ditangani dengan benar. Jika batch pesan gagal, batch berikutnya juga ditandai sebagai gagal hingga pemulihan terjadi, yang dapat difasilitasi oleh file snapshot yang menyimpan pemetaan ID produser ke nomor urut.

![image](https://github.com/user-attachments/assets/ad84f103-aaea-42ec-a60b-5fad50b15cad)

Produser idempotent mencegah catatan duplikat selama sesi produser yang sama, terutama ketika acks=all diatur dan beberapa catatan direplikasi oleh satu pengikut. Jika pemilihan pemimpin terjadi, broker memeriksa nomor urut pesan yang masuk. Jika duplikat ditemukan, broker mengabaikan catatan dan mengembalikan respons DUP kepada klien. Tanpa idempotence, pesan tersebut akan diduplikasi.

## Manage Consumer Group Offsets

Properti konsumen auto.offset.reset menentukan apa yang harus dilakukan jika tidak ada posisi yang dikomit (yang akan terjadi saat grup pertama kali diinisialisasi) atau saat offset berada di luar rentang, yaitu kurang dari offset awal log saat ini atau lebih besar dari offset akhir log.

| Value   | Deskripsi                               |
|---------|-----------------------------------------|
| earliest| Mengatur offset ke yang paling awal tersedia |
| latest  | Mengatur offset ke yang paling baru tersedia |
| none    | Membuang pengecualian jika tidak ada offset valid ditemukan |

Reset offset juga bisa dilakukan secara manual, contohnya dengan command berikut yang mereset offset ke datetime tertentu:

```
kafka-consumer-groups \
    --bootstrap-server kafka-1:9092 \
    --group my-group \
    --topic my_topic \
    --reset-offsets \
    --execute \
    --to-datetime 2021-06-01T17:14:23.933
```

Dalam java, untuk reset ke timestamp tertentu, bisa gunakan code berikut:

```
for (TopicPartition partition : partitions) { 
    timestampsToSearch.put(partition, MY_TIMESTAMP);
}

Map<TopicPartition, OffsetAndTimestamp> result = consumer.offsetsForTimes(timestampsToSearch); 

for (Map.Entry<TopicPartition, OffsetAndTimestamp> entry : result.entrySet()) {
    consumer.seek(entry.getKey(), entry.getValue().offset()); 
}
```

Dalam kode di atas, proses adalah sebagai berikut:
1. Tambahkan setiap Partisi dan stempel waktu ke HashMap
2. Dapatkan offset untuk setiap Partisi
3. Cari offset yang ditentukan untuk setiap Partisi

Pada contoh ini, consumer akan `seekToBeginning` dari semua partisi topik my_topic:

```
ConsumerRebalanceListener listener = new  
    ConsumerRebalanceListener() {
        @Override
        public void onPartitionsRevoked(Collection<TopicPartition> partitions) {
            // nothing to do...
        }

        @Override
        public void onPartitionsAssigned(Collection<TopicPartition> partitions) {
            consumer.seekToBeginning(partitions);
        }
    };
consumer.subscribe(Arrays.asList("my_topic"), listener);  
consumer.poll(Duration.ofMillis(0));  
```

Dalam kode di atas, proses adalah sebagai berikut:
1. Daftarkan ConsumerRebalanceListener
2. Berlangganan topik my_topic
3. Polling untuk catatan dari partisi yang ditetapkan
